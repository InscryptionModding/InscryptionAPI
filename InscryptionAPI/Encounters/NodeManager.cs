using DiskCardGame;
using HarmonyLib;
using InscryptionAPI.Guid;
using InscryptionAPI.Nodes;
using UnityEngine;

namespace InscryptionAPI.Encounters;

[HarmonyPatch]
[Obsolete("NodeManager is deprecated, use NewNodeManager instead.")]
public static class NodeManager
{
    private static List<NodeInfo> AllNodes = new();

    [Flags]
    public enum NodePosition
    {
        /// <summary>
        /// This node will not be autogenerated on the map, but can still be manually added
        /// </summary>
        NotGenerated = 0,

        /// <summary>
        /// This node can appear in Act 1 maps, not just in Kaycee's Mod map
        /// </summary>
        Act1Available = 1,

        /// <summary>
        /// This node will be forced to appear at the start of each map, unless the node fails a prerequisite condition
        /// </summary>
        MapStart = 2,

        /// <summary>
        /// This node will appear in the pool of random events that happen right after a battle
        /// </summary>
        CardChoiceRandom = 4,

        /// <summary>
        /// This node will appear in the pool of random events that happen right before a battle
        /// </summary>
        SpecialEventRandom = 8,

        /// <summary>
        /// This node will be forced to appear right before the boss of each map, unless the node fails a prerequisite condition
        /// </summary>
        PreBoss = 16,

        /// <summary>
        /// This node will be forced to appear right after the boss of each map, unless the node fails a prerequisite condition
        /// </summary>
        PostBoss = 32
    }

    public class NodeInfo
    {
        public Texture2D[] animatedMapNode { get; set; }
        public NodePosition nodePosition { get; set; }
        public Type sequencerType { get; set; }
        public Type nodeDataType { get; set; }
        public string guid { get; internal set; }
        public string ModGUID { get; internal set; }

        public CustomNodeData BuildNode()
        {
            CustomNodeData data = Activator.CreateInstance(this.nodeDataType) as CustomNodeData;
            data.guid = this.guid;
            data.Initialize();
            return data;
        }
    }

    /// <summary>
    /// Registers a new custom node and conditionally adds it to the map pool based on the nodeType
    /// </summary>
    /// <param name="animatedMapNode">An array of exactly four textures containing the node's animation</param>
    /// <param name="nodeType">Flags to indicate where the node should appear on the map</param>
    /// <typeparam name="S">Implements the sequence logic for the special node</typeparam>
    /// <returns>The internal representation of this node</returns>
    public static NodeInfo Add<S>(Texture2D[] animatedMapNode, NodePosition nodeType) where S : MonoBehaviour, ICustomNodeSequence
    {
        return NodeManager.Add<S, CustomNodeData>(animatedMapNode, nodeType);
    }

    /// <summary>
    /// Registers a new custom node and conditionally adds it to the map pool based on the nodeType
    /// </summary>
    /// <param name="animatedMapNode">An array of exactly four textures containing the node's animation</param>
    /// <param name="nodeType">Flags to indicate where the node should appear on the map</param>
    /// <typeparam name="S">Implements the sequence logic for the special node</typeparam>
    /// <typeparam name="N">Implements the custom data and map generation logic for the special node</typeparam>
    /// <returns>The internal representation of this node</returns>
    public static NodeInfo Add<S, N>(Texture2D[] animatedMapNode, NodePosition nodeType) where S : MonoBehaviour, ICustomNodeSequence where N : CustomNodeData
    {
        if (animatedMapNode.Length != 4)
            throw new InvalidDataException($"There must be exactly four animated map textures");

        NodeInfo info = new NodeInfo()
        {
            animatedMapNode = animatedMapNode,
            nodePosition = nodeType,
            sequencerType = typeof(S),
            nodeDataType = typeof(N),
            guid = typeof(S).FullName
        };
        info.ModGUID = TypeManager.GetModIdFromCallstack(typeof(S).Assembly);
        AllNodes.Add(info);
        return info;
    }

    [HarmonyPatch(typeof(SpecialNodeHandler), nameof(SpecialNodeHandler.StartSpecialNodeSequence))]
    [HarmonyPrefix]
    private static bool CustomNodeGenericSelect(ref SpecialNodeHandler __instance, SpecialNodeData nodeData)
    {
        if (nodeData is CustomSpecialNodeData node)
        {
            if (node.Node == null)
            {
                __instance.DoMissingNodeSequence();
            }
            else if (node.Node.IsValidSequencerType())
            {
                List<Transform> children = new();
                for (int i = 0; i < __instance.transform.childCount; i++)
                {
                    Transform child = __instance.transform.GetChild(i);
                    if (child != null)
                    {
                        children.Add(child);
                    }
                }
                Type target = node.Node.GetSequencerType();
                ICustomNodeSequencer existing = children.Find(x => x.GetComponent(target) != null)?.GetComponent<ICustomNodeSequencer>();
                if (existing != null)
                {
                    __instance.StartCoroutine(NewNodeManager.CustomNodeSequence(existing, node));
                }
                else
                {
                    GameObject sequencerObject;
                    if (node.Node.sequencerPrefab != null)
                    {
                        sequencerObject = UnityObject.Instantiate(node.Node.sequencerPrefab, __instance.transform);
                    }
                    else
                    {
                        sequencerObject = new(target.Name);
                        sequencerObject.transform.parent = __instance.transform;
                    }
                    sequencerObject.transform.localPosition = Vector3.zero;
                    if (node.Node.nodeSequencerType != null)
                    {
                        existing = (sequencerObject.GetComponent(node.Node.nodeSequencerType) ?? sequencerObject.AddComponent(node.Node.nodeSequencerType)) as ICustomNodeSequencer;
                    }
                    else
                    {
                        existing = sequencerObject.GetComponent(target) as ICustomNodeSequencer;
                    }
                    if (existing != null)
                    {
                        if (existing is IInherit inherit)
                        {
                            inherit.Inherit(node);
                        }
                        __instance.StartCoroutine(NewNodeManager.CustomNodeSequence(existing, node));
                    }
                    else
                    {
                        __instance.DoMissingSequenceSequence();
                    }
                }
            }
            else
            {
                __instance.DoMissingSequenceSequence();
            }
            return false;
        }
        // This sends the player to the upgrade shop if the triggering node is SpendExcessTeeth
        else if (nodeData is CustomNodeData genericNode)
        {
            NodeInfo info = AllNodes.FirstOrDefault(ni => ni.guid == genericNode.guid);

            if (info == null)
                return true;

            Type customNodeType = info.sequencerType;

            if (customNodeType == null)
                return true;

            ICustomNodeSequence sequence = __instance.gameObject.GetComponent(customNodeType) as ICustomNodeSequence;
            if (sequence == null)
                sequence = __instance.gameObject.AddComponent(customNodeType) as ICustomNodeSequence;

            __instance.StartCoroutine(sequence.ExecuteCustomSequence(genericNode));
            return false; // This prevents the rest of the thing from running.
        }
        return true; // This makes the rest of the thing run
    }

    [HarmonyPatch(typeof(MapDataReader), nameof(MapDataReader.GetPrefabPath))]
    [HarmonyPostfix]
    private static void TrimPrefabPath(ref string __result)
    {
        // So, for some reason, the map data reader doesn't just
        // straight up read the property of the map node.
        // It passes through here first.
        // That's convenient! We will trim our extra instructions off here
        // Then we'll read that information off later
        if (__result.Contains('@'))
            __result = __result.Substring(0, __result.IndexOf('@')); // Get rid of everything after the @
    }

    [HarmonyPatch(typeof(MapDataReader), nameof(MapDataReader.SpawnAndPlaceElement))]
    [HarmonyPrefix]
    private static bool CreateNodePrefab(MapDataReader __instance, ref GameObject __result, MapElementData data, Vector2 sampleRange, bool isScenery)
    {
        if (!isScenery && data is CustomSpecialNodeData sdata && sdata.Node?.nodePrefab != null)
        {
            GameObject gameObject;
            gameObject = UnityObject.Instantiate(sdata.Node.nodePrefab);
            gameObject.transform.SetParent(__instance.nodesParent);
            gameObject.transform.localPosition = __instance.GetRealPosFromDataPos(data.position, sampleRange);
            __result = gameObject;
            return false;
        }
        return true;
    }

    [HarmonyPatch(typeof(MapDataReader), nameof(MapDataReader.SpawnAndPlaceElement))]
    [HarmonyPostfix]
    private static void TransformMapNode(ref GameObject __result, MapElementData data, bool isScenery)
    {
        if (!isScenery)
        {
            // First, let's see if we need to do anything
            if (data is CustomSpecialNodeData)
            {
                (data as CustomSpecialNodeData).OnPostGeneration(__result.GetComponentInChildren<MapNode2D>());
            }
            else if (data.PrefabPath.Contains('@'))
            {
                string guid = data.PrefabPath.Substring(data.PrefabPath.IndexOf('@') + 1);

                NodeInfo info = AllNodes.FirstOrDefault(ni => ni.guid == guid);

                if (info == null)
                    return;

                Texture2D[] nodeTextures = info.animatedMapNode;

                if (nodeTextures == null)
                    return;

                // Replace the sprite
                AnimatingSprite sprite = __result.GetComponentInChildren<AnimatingSprite>();

                bool loadedTexture = false;
                for (int i = 0; i < sprite.textureFrames.Count; i++)
                {
                    if (sprite.textureFrames[i].name != $"InscryptionAPI_{guid}_{i + 1}")
                    {
                        sprite.textureFrames[i] = nodeTextures[i];
                        loadedTexture = true;
                    }
                }

                if (loadedTexture)
                    sprite.IterateFrame();
            }
            else if (data is BossBattleNodeData boss)
            {
                AnimatingSprite sprite = __result.GetComponentInChildren<AnimatingSprite>();
                OpponentManager.FullOpponent opponent = OpponentManager.NewOpponents.ToList().Find(x => x.Id == boss.bossType);
                if (sprite != null && opponent != null && opponent.NodeAnimation != null && opponent.NodeAnimation.Count > 0)
                {
                    sprite.textureFrames = new(opponent.NodeAnimation);
                    sprite.SetTexture(sprite.textureFrames[0]);
                }
            }
        }
    }

    [HarmonyPatch(typeof(MapGenerator), nameof(MapGenerator.ChooseSpecialNodeFromPossibilities))]
    [HarmonyPrefix]
    private static void AddNodePossibilities(List<NodeData> possibilities)
    {
        // Let's figure out what stage we're at by looking at what's in the list already
        NodePosition type = NodePosition.NotGenerated;
        if (possibilities.Exists(nd => nd is GainConsumablesNodeData))
            type = NodePosition.SpecialEventRandom;
        else if (possibilities.Exists(nd => nd is BuyPeltsNodeData))
            type = NodePosition.CardChoiceRandom;

        if (type == NodePosition.NotGenerated)
            return;

        // This means that we're being asked to pick a special event (what happens after picking a card but before battling)
        foreach (NodeInfo info in AllNodes.Where(ni => ni.nodePosition.HasFlag(type)))
            possibilities.Add(info.BuildNode());
        GenerationType type2 = type is NodePosition.SpecialEventRandom ? GenerationType.SpecialEvent : GenerationType.SpecialCardChoice;
        foreach (NewNodeManager.FullNode node in NewNodeManager.NewNodes)
        {
            if (node != null && node.generationType.HasFlag(type2))
            {
                possibilities.Add(new CustomSpecialNodeData(node));
            }
        }
    }

    private static void LinkNodes(List<NodeData> nodes, int startY, List<NodeData> previousNodes)
    {
        int i = 0;
        while (i < nodes.Count)
        {
            if (!nodes[i].MapGenerationPrequisitesMet(startY + i, i == 0 ? previousNodes : previousNodes.Concat(nodes.Take(i)).ToList()))
            {
                nodes.RemoveAt(i);
                continue;
            }

            nodes[i].gridY = startY + i;
            nodes[i].gridX = 1;
            nodes[i].id = MapGenerator.GetNewID();

            if (i > 0)
            {
                if (nodes[i - 1].connectedNodes == null)
                    nodes[i - 1].connectedNodes = new();

                nodes[i - 1].connectedNodes.Add(nodes[i]);
            }

            i++;
        }
    }

    private static bool ValidFor(this NodePosition nodePosition, NodePosition flagMatch)
    {
        return nodePosition.HasFlag(flagMatch) && (SaveFile.IsAscension || nodePosition.HasFlag(NodePosition.Act1Available));
    }

    private static NodeData GetLastNodeBeforeCustomFront(List<NodeData> nodes)
    {
        if (MapGenerator.ForceFirstNodeTraderForAscension(1))
            return nodes.First(n => n.gridY == 1);
        else
            return nodes.First(n => n.gridY == 0);
    }

    [HarmonyPatch(typeof(MapGenerator), nameof(MapGenerator.GenerateNodes))]
    [HarmonyPostfix]
    private static void AddStartEndCustomNodes(ref List<NodeData> __result)
    {
        // We need to create a list of all of the new nodes that go at the front
        int frontStart = MapGenerator.ForceFirstNodeTraderForAscension(1) ? 2 : 1;
        List<NodeData> frontNodes = new List<NodeData>();
        foreach (NodeInfo info in AllNodes.Where(ni => ni.nodePosition.ValidFor(NodePosition.MapStart)))
        {
            frontNodes.Add(info.BuildNode());
        }

        foreach (NewNodeManager.FullNode node in NewNodeManager.NewNodes)
        {
            if (node != null && node.generationType.HasFlag(GenerationType.RegionStart))
            {
                frontNodes.Add(new CustomSpecialNodeData(node));
            }
        }

        // This filters out nodes that shouldn't be there and links them in order
        LinkNodes(frontNodes, frontStart, new());

        // This takes the nodes and injects them into the beginning of the map (extending the map in the process)
        if (frontNodes.Count > 0)
        {
            foreach (NodeData node in __result.Where(n => n.gridY >= frontStart).ToList())
                node.gridY += frontNodes.Count;

            NodeData lastFrontNode = GetLastNodeBeforeCustomFront(__result);
            lastFrontNode.connectedNodes.Clear();
            lastFrontNode.connectedNodes.Add(frontNodes[0]);

            foreach (NodeData firstNextNode in __result.Where(n => n.gridY == frontStart + frontNodes.Count))
                frontNodes[frontNodes.Count - 1].connectedNodes.Add(firstNextNode);

            __result = __result.Where(n => n.gridY < frontStart).Concat(frontNodes).Concat(__result.Where(n => n.gridY >= frontStart)).ToList();
        }

        // These nodes go before the boss
        List<NodeData> preBossNodes = new List<NodeData>();
        foreach (NodeInfo info in AllNodes.Where(ni => ni.nodePosition.ValidFor(NodePosition.PreBoss)))
            preBossNodes.Add(info.BuildNode());

        int bossY = __result.Select(n => n.gridY).Max();
        NodeData bossBattleNode = __result.First(n => n.gridY == bossY);

        foreach (NewNodeManager.FullNode node in NewNodeManager.NewNodes)
        {
            if (node != null && node.generationType.HasFlag(GenerationType.PreBoss))
            {
                preBossNodes.Add(new CustomSpecialNodeData(node));
            }
        }

        LinkNodes(preBossNodes, bossY, new(__result.Where(n => n.gridY < bossY)));

        if (preBossNodes.Count > 0)
        {
            List<NodeData> originalPreBossDataNodes = __result.Where(n => n.connectedNodes.Contains(bossBattleNode)).ToList();

            foreach (NodeData node in originalPreBossDataNodes)
            {
                node.connectedNodes.Clear();
                node.connectedNodes.Add(preBossNodes[0]);
            }

            bossBattleNode.gridY = preBossNodes[preBossNodes.Count - 1].gridY + 1;
            preBossNodes[preBossNodes.Count - 1].connectedNodes.Add(bossBattleNode);

            __result = __result.Where(n => n != bossBattleNode).Concat(preBossNodes).ToList();
            __result.Add(bossBattleNode);
        }

        // These nodes go after the boss
        List<NodeData> postBossNodes = new List<NodeData>();
        foreach (NodeInfo info in AllNodes.Where(ni => ni.nodePosition.ValidFor(NodePosition.PostBoss)))
            postBossNodes.Add(info.BuildNode());

        foreach (NewNodeManager.FullNode node in NewNodeManager.NewNodes)
        {
            if (node != null && node.generationType.HasFlag(GenerationType.PostBoss))
            {
                postBossNodes.Add(new CustomSpecialNodeData(node));
            }
        }

        LinkNodes(postBossNodes, bossBattleNode.gridY + 1, new(__result));

        if (postBossNodes.Count > 0)
        {
            bossBattleNode.connectedNodes = new();
            bossBattleNode.connectedNodes.Add(postBossNodes[0]);
            __result = __result.Concat(postBossNodes).ToList();
        }
    }

    [HarmonyPatch(typeof(MapGenerator), nameof(MapGenerator.GenerateMap))]
    [HarmonyPostfix]
    private static void FixMapLength(ref MapData __result, int gridWidth, RegionData region)
    {
        if (region.predefinedNodes == null)
        {
            __result.gridLength = __result.nodeData.Select(n => n.gridY).Max() + 1;
            __result.mapLength = (float)__result.gridLength * 0.185f;
            MapGenerator.PositionNodes(__result.nodeData, __result.mapLength, gridWidth, __result.gridLength);
        }
    }
}