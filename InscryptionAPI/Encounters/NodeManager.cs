using DiskCardGame;
using HarmonyLib;
using UnityEngine;

namespace InscryptionAPI.Encounters;

[HarmonyPatch]
public static class NodeManager
{
    private static List<NodeInfo> AllNodes = new();

    [Flags] public enum NodePosition
    {
        /// <summary>
        /// This node will not be autogenerated on the map, but can still be manually added
        /// </summary>
        NotGenerated = 0,

        /// <summary>
        /// This node can appear in Act 1 maps, not just in Kaycee's Mod map
        /// </summary>
        Act1Available = 1,

        /// <summary>
        /// This node will be forced to appear at the start of each map, unless the node fails a prerequisite condition
        /// </summary>
        MapStart = 2,

        /// <summary>
        /// This node will appear in the pool of random events that happen right after a battle
        /// </summary>
        CardChoiceRandom = 4,

        /// <summary>
        /// This node will appear in the pool of random events that happen right before a battle
        /// </summary>
        SpecialEventRandom = 8,

        /// <summary>
        /// This node will be forced to appear right before the boss of each map, unless the node fails a prerequisite condition
        /// </summary>
        PreBoss = 16,

        /// <summary>
        /// This node will be forced to appear right after the boss of each map, unless the node fails a prerequisite condition
        /// </summary>
        PostBoss = 32
    }

    public class NodeInfo
    {
        public Texture2D[] animatedMapNode { get; set; }
        public NodePosition nodePosition { get; set; }
        public Type sequencerType { get; set; }
        public Type nodeDataType { get; set; }
        public string guid { get; internal set; }

        public CustomNodeData BuildNode()
        {
            CustomNodeData data = Activator.CreateInstance(this.nodeDataType) as CustomNodeData;
            data.guid = this.guid;
            data.Initialize();
            return data;
        }
    }

    /// <summary>
    /// Registers a new custom node and conditionally adds it to the map pool based on the nodeType
    /// </summary>
    /// <param name="animatedMapNode">An array of exactly four textures containing the node's animation</param>
    /// <param name="nodeType">Flags to indicate where the node should appear on the map</param>
    /// <typeparam name="S">Implements the sequence logic for the special node</typeparam>
    /// <returns>The internal representation of this node</returns>
    public static NodeInfo Add<S>(Texture2D[] animatedMapNode, NodePosition nodeType) where S : ManagedBehaviour, ICustomNodeSequence
    {
        return NodeManager.Add<S, CustomNodeData>(animatedMapNode, nodeType);
    }

    /// <summary>
    /// Registers a new custom node and conditionally adds it to the map pool based on the nodeType
    /// </summary>
    /// <param name="animatedMapNode">An array of exactly four textures containing the node's animation</param>
    /// <param name="nodeType">Flags to indicate where the node should appear on the map</param>
    /// <typeparam name="S">Implements the sequence logic for the special node</typeparam>
    /// <typeparam name="N">Implements the custom data and map generation logic for the special node</typeparam>
    /// <returns>The internal representation of this node</returns>
    public static NodeInfo Add<S, N>(Texture2D[] animatedMapNode, NodePosition nodeType) where S : ManagedBehaviour, ICustomNodeSequence where N : CustomNodeData
    {
        if (animatedMapNode.Length != 4)
            throw new InvalidDataException($"There must be exactly four animated map textures");

        NodeInfo info = new NodeInfo() {
            animatedMapNode = animatedMapNode,
            nodePosition = nodeType,
            sequencerType = typeof(S),
            nodeDataType = typeof(N),
            guid = typeof(S).FullName
        };
        AllNodes.Add(info);
        return info;
    }

    [HarmonyPatch(typeof(SpecialNodeHandler), nameof(SpecialNodeHandler.StartSpecialNodeSequence))]
    [HarmonyPrefix]
    private static bool CustomNodeGenericSelect(ref SpecialNodeHandler __instance, SpecialNodeData nodeData)
    {
        // This sends the player to the upgrade shop if the triggering node is SpendExcessTeeth
        if (nodeData is CustomNodeData genericNode)
        {
            NodeInfo info = AllNodes.FirstOrDefault(ni => ni.guid == genericNode.guid);

            if (info == null)
                return true;

            Type customNodeType = info.sequencerType;

            if (customNodeType == null)
                return true;

            ICustomNodeSequence sequence = __instance.gameObject.GetComponent(customNodeType) as ICustomNodeSequence;
            if (sequence == null)
                sequence = __instance.gameObject.AddComponent(customNodeType) as ICustomNodeSequence;

            __instance.StartCoroutine(sequence.ExecuteCustomSequence(genericNode));
            return false; // This prevents the rest of the thing from running.
        }
        return true; // This makes the rest of the thing run
    }

    [HarmonyPatch(typeof(MapDataReader), nameof(MapDataReader.GetPrefabPath))]
    [HarmonyPostfix]
    private static void TrimPrefabPath(ref string __result)
    {
        // So, for some reason, the map data reader doesn't just
        // straight up read the property of the map node.
        // It passes through here first.
        // That's convenient! We will trim our extra instructions off here
        // Then we'll read that information off later
        if (__result.Contains('@'))
            __result = __result.Substring(0, __result.IndexOf('@')); // Get rid of everything after the @
    }

    [HarmonyPatch(typeof(MapDataReader), nameof(MapDataReader.SpawnAndPlaceElement))]
    [HarmonyPostfix]
    private static void TransformMapNode(ref GameObject __result, MapElementData data)
    {
        // First, let's see if we need to do anything
        if (data.PrefabPath.Contains('@'))
        {   
            string guid = data.PrefabPath.Substring(data.PrefabPath.IndexOf('@') + 1);

            NodeInfo info = AllNodes.FirstOrDefault(ni => ni.guid == guid);

            if (info == null)
                return;

            Texture2D[] nodeTextures = info.animatedMapNode;

            if (nodeTextures == null)
                return;

            // Replace the sprite
            AnimatingSprite sprite = __result.GetComponentInChildren<AnimatingSprite>();

            bool loadedTexture = false;
            for (int i = 0; i < sprite.textureFrames.Count; i++)
            {
                if (sprite.textureFrames[i].name != $"InscryptionAPI_{guid}_{i+1}")
                {
                    sprite.textureFrames[i] = nodeTextures[i];
                    loadedTexture = true;
                }
            }

            if (loadedTexture)
                sprite.IterateFrame();
        }
    }
    
    [HarmonyPatch(typeof(MapGenerator), nameof(MapGenerator.ChooseSpecialNodeFromPossibilities))]
    [HarmonyPrefix]
    private static void AddNodePossibilities(List<NodeData> possibilities)
    {
        // Let's figure out what stage we're at by looking at what's in the list already
        NodePosition type = NodePosition.NotGenerated;
        if (possibilities.Exists(nd => nd is GainConsumablesNodeData))
            type = NodePosition.SpecialEventRandom;
        else if (possibilities.Exists(nd => nd is BuyPeltsNodeData))
            type = NodePosition.CardChoiceRandom;
        
        if (type == NodePosition.NotGenerated)
            return;

        // This means that we're being asked to pick a special event (what happens after picking a card but before battling)
        foreach (NodeInfo info in AllNodes.Where(ni => ni.nodePosition.HasFlag(type)))
            possibilities.Add(info.BuildNode());
    }

    private static void LinkNodes(List<NodeData> nodes, int startY, List<NodeData> previousNodes)
    {
        int i = 0;
        while (i < nodes.Count)
        {
            if (!nodes[i].MapGenerationPrequisitesMet(startY + i, i == 0 ? previousNodes : previousNodes.Concat(nodes.Take(i)).ToList()))
            {
                nodes.RemoveAt(i);
                continue;
            }

            nodes[i].gridY = startY + i;
            nodes[i].gridX = 1;
            nodes[i].id = MapGenerator.GetNewID();

            if (i > 0)
            {
                if (nodes[i-1].connectedNodes == null)
                    nodes[i-1].connectedNodes = new();

                nodes[i-1].connectedNodes.Add(nodes[i]);
            }

            i++;
        }
    }

    private static bool ValidFor(this NodePosition nodePosition, NodePosition flagMatch)
    {
        return nodePosition.HasFlag(flagMatch) && (SaveFile.IsAscension || nodePosition.HasFlag(NodePosition.Act1Available));
    }

    private static NodeData GetLastNodeBeforeCustomFront(List<NodeData> nodes)
    {
        if (MapGenerator.ForceFirstNodeTraderForAscension(1))
            return nodes.First(n => n.gridY == 1);
        else
            return nodes.First(n => n.gridY == 0);
    }

    [HarmonyPatch(typeof(MapGenerator), nameof(MapGenerator.GenerateNodes))]
    [HarmonyPostfix]
    private static void AddStartEndCustomNodes(ref List<NodeData> __result)
    {
        // We need to create a list of all of the new nodes that go at the front
        int frontStart = MapGenerator.ForceFirstNodeTraderForAscension(1) ? 2 : 1;
        List<NodeData> frontNodes = new List<NodeData>();
        foreach (NodeInfo info in AllNodes.Where(ni => ni.nodePosition.ValidFor(NodePosition.MapStart)))
            frontNodes.Add(info.BuildNode());

        // This filters out nodes that shouldn't be there and links them in order
        LinkNodes(frontNodes, frontStart, new());

        // This takes the nodes and injects them into the beginning of the map (extending the map in the process)
        if (frontNodes.Count > 0)
        {
            foreach(NodeData node in __result.Where(n => n.gridY >= frontStart).ToList())
                node.gridY += frontNodes.Count;

            NodeData lastFrontNode = GetLastNodeBeforeCustomFront(__result);
            lastFrontNode.connectedNodes.Clear();
            lastFrontNode.connectedNodes.Add(frontNodes[0]);

            foreach (NodeData firstNextNode in __result.Where(n => n.gridY == frontStart + frontNodes.Count))
                frontNodes[frontNodes.Count - 1].connectedNodes.Add(firstNextNode);
            
            __result = __result.Where(n => n.gridY < frontStart).Concat(frontNodes).Concat(__result.Where(n => n.gridY >= frontStart)).ToList();
        }

        // These nodes go before the boss
        List<NodeData> preBossNodes = new List<NodeData>();
        foreach (NodeInfo info in AllNodes.Where(ni => ni.nodePosition.ValidFor(NodePosition.PreBoss)))
            preBossNodes.Add(info.BuildNode());

        int bossY = __result.Select(n => n.gridY).Max();
        NodeData bossBattleNode = __result.First(n => n.gridY == bossY);
        LinkNodes(preBossNodes, bossY, new(__result.Where(n => n.gridY < bossY)));

        if (preBossNodes.Count > 0)
        {
            List<NodeData> originalPreBossDataNodes = __result.Where(n => n.connectedNodes.Contains(bossBattleNode)).ToList();

            foreach(NodeData node in originalPreBossDataNodes)
            {
                node.connectedNodes.Clear();
                node.connectedNodes.Add(preBossNodes[0]);
            }

            bossBattleNode.gridY = preBossNodes[preBossNodes.Count - 1].gridY + 1;
            preBossNodes[preBossNodes.Count - 1].connectedNodes.Add(bossBattleNode);

            __result = __result.Where(n => n != bossBattleNode).Concat(preBossNodes).ToList();
            __result.Add(bossBattleNode);
        }

        // These nodes go after the boss
        List<NodeData> postBossNodes = new List<NodeData>();
        foreach (NodeInfo info in AllNodes.Where(ni => ni.nodePosition.ValidFor(NodePosition.PostBoss)))
            postBossNodes.Add(info.BuildNode());

        LinkNodes(postBossNodes, bossBattleNode.gridY + 1, new(__result));

        if (postBossNodes.Count > 0)
        {
            bossBattleNode.connectedNodes = new();
            bossBattleNode.connectedNodes.Add(postBossNodes[0]);
            __result = __result.Concat(postBossNodes).ToList();
        }
    }

    [HarmonyPatch(typeof(MapGenerator), nameof(MapGenerator.GenerateMap))]
    [HarmonyPostfix]
    private static void FixMapLength(ref MapData __result, int gridWidth)
    {
        __result.gridLength = __result.nodeData.Select(n => n.gridY).Max() + 1;
        __result.mapLength = (float)__result.gridLength * 0.185f;
        MapGenerator.PositionNodes(__result.nodeData, __result.mapLength, gridWidth, __result.gridLength);
    }
}